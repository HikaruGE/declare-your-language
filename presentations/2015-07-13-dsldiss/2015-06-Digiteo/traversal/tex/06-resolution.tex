\section{Resolution Algorithm}
\sectionlabel{resolution-algorithm}

In this section, we describe an algorithm for computing program resolutions in the sense of
\Section{progresolutionspec}.  Suppose we have a program $p$ from which we collect a set of 
assumptions $\semop{p} = A_p \wedge C_p$, where $A_p$ is a conjunction of assumptions and
$C_p$ is a conjunction of pure constraints.  Then recall that a {\em resolution} for $p$
is a multi-sorted substitution $\phi$ and a typing environment $\psi$ such that \vspace*{-2mm}
\begin{equation}\tag{$\diamond$}
  \label{eq:resoleq}
 |\phi(A_p)|,\psi \models \phi(C_p)  
\vspace*{-2mm}\end{equation}
Our algorithm works only for a restricted class of generated constraints: all
assumptions must be ground, except that (i) scope variables $\varsigma$ can appear in
direct import assumptions (e.g. $\ASImport{\varsigma}{S}$), and (ii) type variables $\tau$
and declaration variables $\delta$ can appear on the right-hand side of a subtyping assumption 
(e.g. $\ASubtype{\recty{\di{A}{i}}}{\recty{\delta}}$).
This restriction is met by the constraints generated by the LMR collection
algorithm in \Section{collection}.  Broader classes of constraints might be
useful for other languages; we defer exploration of algorithms that could handle these
to future work. 


\subsection{Handling Variables in Assumptions}

The basic approach of the algorithm is to apply the definitions in Section~\ref{ssec:assumptionsem} to the
assumptions to build a scope graph and a subtyping relation, and then use these 
to resolve pure constraints of the form $\CResolve{\r{x}}{d}$ or $\CSubtype{t_1}{t_2}$ in the context of a 
conventional unification-based algorithm.
However, since the assumptions can contain variables, we cannot fully define the scope graph or subtyping
relation before starting constraint resolution, because we don't fully know $\phi$. 
Thus, our algorithm builds $\phi$ (and $\Psi$) incrementally.  The key idea is that
we can resolve some pure constraints even when $\phi$ is not yet fully defined,
in such a way that the resolution remains valid as it becomes more defined.

\paragraph{Sub-typing}
The construction of the sub-typing relation from a set of ground assumptions
given in Section \ref{ssec:assumptionsem} is monotonic. Let $\leq_A$ be the subtyping order generated from a set of 
ground assumptions $A$. 
Then given two sets of grounds assumptions $A_1$ and $A_2$, we have the following property: \vspace*{-2mm}
$$A_1 \subseteq A_2 \Rightarrow T_1 \leq_{A_1} T_2 \Rightarrow  T_1 \leq_{A_2} T_2\vspace*{-2mm}$$
%If a set of assumption is included in another set of assumption then its corresponding sub-typing relation is also included in the subtyping relation of the other. 
If $A$ is any set of (not necessarily ground) assumptions, and $\overline{A}$ is its subset of ground assumptions, 
then for all substitutions $\phi$ mapping type variable to ground types we have:\vspace*{-2mm}
$$ T_1 \leq_{\overline{A}} T_2 \Rightarrow  T_1 \leq_{\phi(A)} T_2\vspace*{-2mm}$$
Therefore, if we can deduce a subtyping relation between two types by only using the ground assumptions then this relation 
will still hold under any subsequent substitution. 
% Therefore, if at some point of the resolution we have the partial substitution $\phi$, meaning that if there is a solution $\phi_p$ then there exists $\sigma$ such that $\phi_p=\sigma\circ\phi$, then every sub-typing we can deduce at this point using the assumptions grounded by $\phi$ will remain true in the final solution:
% $$ T_1 \leq_{\overline{\phi(A_p)}} T_2 \Rightarrow T_1 \leq_{\phi'(A_p)} T_2  $$   
% \APT{This last equation uses undefined things. (And could just omit.)} 

\paragraph{Scope Graphs}

\input{figures/nameresolutionalgo}

The situation is a bit more complicated with respect to scope graphs.
The non-strictly positive premise of the (V) rule of the resolution calculus
makes the derivation of a resolution relation from a graph non-monotonic with
respect to additions to the graph.
For example, suppose that in some graph $\G$ a reference $\r{x}$ in a scope $S$ resolves to declaration $\di{x}{i}$ 
in the parent scope $S'$. In a bigger graph $\G'$ that also has a declaration $\di{x}{i'}$ in $S$ itself, 
$\r{x}$ will resolve to $\di{x}{i'}$, and the old resolution to $\di{x}{i}$ will be shadowed. 
Therefore we can not simply resolve a reference in a graph built from ground assumptions and expect this
resolution to remain valid later in the resolution process.

However, we have restricted the set of constraints we handle so that almost all assumptions used for scope graph construction are 
in fact ground from the beginning.  The only exception is for direct import declarations, where
the imported scope can be a scope variable; this construction is essential for expressing record field access, where the
resolution of the field name depends on the type of the record expression.
% The only one that are not are the direct import declaration where the imported scope can be variable. These direct imports are used to represent scope import induced by a typing relation. For example, given the expression {\sf a.x} where {\sf a} is an object, we interpret the construction {\sf a.\_} as opening new scope (e.g. $S_1$) with no parent and one direct imported scope corresponding to the type (class definition) of {\sf a}, say $S_a$. Then {\sf x} will be resolved in this scope $S_1$ using this direct import. 
%
%When starting the resolution process, one can not know what is this imported scope $S_a$ since finding it first requires to type {\sf a} which requires to resolve the reference {\sf a} to its definition. Therefore, in the assumption corresponding to the scope graph declaration the scope imported in $S_1$ is identified by a variable $\varsigma$. In the constraint, this variable $\varsigma$ is also related to the type of the expression $a$. Then, at some point in the resolution, it will be resolved to the scope $S_a$ allowing us to resolve {\sf x} in $S_1$ using the import $S_a$. But this resolution requires to be able to find the type of the sub-expression $a$ by using name resolution with this variable import. That means we need to resolve {\sf a} such that the resolution will remain valid whatever scope $\varsigma$ will eventually get bound to. 
%
% \paragraph{Incomplete scope graph}
%
% In Section \ref{ssec:assumptionsem}, we explained the construction of a scope graph from a given set of ground assumptions. We just saw that the set of assumptions defining the scope graph can in fact contains some variable in direct import position. 
In order to handle these unknown direct imports,
we define an extension of the scope graph structure, called an \emph{incomplete scope graph}, that also allows scope variables as direct imports in addition to ground scopes. The construction of the incomplete scope graph from a set of assumptions with variable direct imports is similar to the one for ordinary scope graphs construction given in Section \ref{ssec:assumptionsem}. 

The resolution calculus as presented in \Figure{rescalc} is only defined on ground scope graphs. Given an incomplete scope graph $\G$, a reference $\r{x}$ is said to resolve to a declaration $\di{x}{i}$ if and only if this resolution is valid in all ground instance of this incomplete graph:\vspace*{-2mm}
\begin{equation}\tag{$\blacklozenge$}
  \label{eq:nameres}
 \vdash_\G \r{x} \resolve \di{x}{i} \ \stackrel{\Delta}{=}\ \forall\ \sigma,\ \vdash_{\G.\sigma} \r{x} \resolve \di{x}{i}     \vspace*{-2mm}
\end{equation}
where we write $\vdash_\G$ for the resolution relation for graph $\G$ and 
$\G.\sigma$ is the ground scope graph corresponding to the application of substitution $\sigma$ to variables in $\G$.
In order to be able to detect eventual duplicate resolutions in the program we also want to ensure that an incomplete graph
provides \emph{all} the possible resolutions of a given reference. In particular, if a resolution is unique in an incomplete graph, we want it to be unique in all its ground instances. 
An incomplete graph $\G$ is stable for a reference $\r{x}$, denoted $\stable{\G}{\r{x}}$, if all the resolutions in all its ground instances are the same:\vspace*{-2mm}
$$\stable{\G}{\r{x}} \stackrel{\Delta}{=}\ \forall \sigma, \sigma' \vdash_{\G.\sigma} \r{x} \resolve \di{x}{i} \Rightarrow \vdash_{\G.\sigma'} \r{x} \resolve \di{x}{i}\vspace*{-2mm}$$

The resolution algorithm in \Figure{name-resolution} defines resolution in (potentially) incomplete scope graphs. The $\lhd$ operator is defined by $S_1 \lhd S_2 \stackrel{\Delta}{=} \text{\it if }S_1 \neq \emptyset\ \text{\it then } S_1\ \text{\it else } S_2$.
 This algorithm raises an 
exception if the graph is not stable for the reference.\vspace*{-2mm}
\begin{equation}\tag{$\star$}
  \label{eq:nameresspec}
\di{x}{i} \in \ResG{\G}{\r{x}}\ \Longrightarrow\ \vdash_\G \r{x} \resolve \di{x}{i} \wedge \stable{\G}{\r{x}} \vspace*{-2mm}
\end{equation}
where $\ResG{\G}{\r{x}}$ denotes the main resolution function $\Res{\emptyset}{\r{x}}$ of the graph $\G$.

We now sketch of proof of correctness for this algorithm.
First, notice that the algorithm terminates using the lexicographic ordering ($\#(\R{\G}\backslash\seeni),\#(\S{G}\backslash\seens)$), where $\#(A)$ denotes the cardinality of set A.
We next prove that on ground scope graphs, this algorithm behaves like the standard resolution algorithm presented in 
\cite{NeronTVW-ESOP-2015}.  If $\G$ is ground then:\vspace*{-2mm}
\begin{equation}\tag{i}
  \label{eq:resground}
 \ResGx{\G}{\seeni}{\r{x}} = \{ \di{x}{i} \mid \seeni \vdash_\G \r{x} \resolve \di{x}{i}\}\vspace*{-2mm}
\end{equation}
\begin{proof}
In this case, since the graph is ground, no exceptions can be thrown. Therefore the proof is an adaptation of Theorem~1 of \cite{NeronTVW-ESOP-2015}. The only differences are:
(a) the extra case of direct imports, which can be simply handled by adapting the name import case of the original proof; and
(b) the fact that instead of computing the complete sets of visible and reachable declarations, the auxiliary algorithms only compute the ones matching the name argument.
\end{proof}

Now let $\G$ be an incomplete scope graph and $\G'$ one of its instances. If a resolution on $\G$ terminates with a set of declarations then the resolution on $\G'$ does too:\vspace*{-2mm}
\begin{equation}\tag{ii}
  \label{eq:reseq}
  \ResGx{\G}{\seeni}{\r{x}} = S \Longrightarrow  \ResGx{\G'}{\seeni}{\r{x}} = S  \vspace*{-2mm}
\end{equation}

\begin{proof} By induction on the termination order of the algorithm ($\#(\R(\G)\backslash\seeni),\#(\S{G}\backslash\seens)$). 
Since exceptions are never caught, and since an exception is triggered as soon as a scope variable is encountered, if the a run of the algorithm on $\G$ starting from $\r{x}$ does terminate with a with a result then this run is exactly the same on $\G'$. 
\end{proof}

Finally, we can prove \ref{eq:nameresspec}:
%\begin{equation*}
%\d{x} \in \ResG{\G}{\r{x}} \Longrightarrow \vdash_\G \r{x} \resolve \d{x}   \wedge  \stable{\G}{\r{x}} 
%\end{equation*}
\begin{proof}
Let $S = \ResG{\G}{\r{x}}$ and pick $\di{x}{i} \in S$.

To prove that $\r{x}$ resolves to $\di{x}{i}$ in $\G$, let $\G'$ be an arbitrary ground instance of $\G$.  
Using (\ref{eq:reseq}) we have $\di{x}{i} \in \ResG{\G'}{\r{x}}$ and by (\ref{eq:resground}) we have
$\vdash_{\G'} \r{x} \resolve \di{x}{i}$. By \ref{eq:nameres}, 
we get that $\vdash_\G \r{x} \resolve \di{x}{i}$.

To prove stability, let $\G_1$ and $\G_2$ be ground instances of $\G$. Then by (\ref{eq:reseq}), $\ResG{\G_1}{\r{x}} = S = \ResG{\G_2}{\r{x}}$, so by definition we have $\stable{\G}{\r{x}}$.
\end{proof}

\subsection{Constraint Solving Algorithm}
\newcommand{\alabl}[1]{\textsc{(#1)}}
\newcommand{\leqa}{A}
\input{figures/constraint-solver}

In \Figure{constraint-solver} we present an algorithm to solve the
constraint system from \Section{constraintlang}. The algorithm is a
non-deterministic rewrite system working over tuples $(C,\G,\leqa,\psi)$ of a
constraint, a scope graph, a set of subtyping assumptions and a typing
environment. It is non-deterministic in the sense that rules may be
applied to any atomic constraint in any order considering that 
$\wedge$ is associative and commutative. 

Name resolution introduces ambiguity, since a reference $\r{x}$ may
resolve to multiple definitions. If this happens the solver branches,
picking a different resolution for $\r{x}$ in every branch. The
returned solution is a set of all the $(C,\G,\leqa,\psi)$ tuples the
solver was able to construct.
The initial state of the solver is the collected constraint, the
(incomplete) scope graph built from the scope graph assumptions, 
the sub-typing assumptions
and an empty typing environment. The algorithm will eliminate clauses
from $C$ while instantiating $\G$ and $\leqa$ and filling $\psi$. The
algorithm terminates when the constraint is empty or no more clauses
can be solved. 
% Any unsolved constraint corresponds to some error in
% the program.\APT{This last sentence seems wrong to me -- it just means
% this particular path failed.}
Each rule solves one constraint, possibly updating components of
the tuple or applying a substitution to it. The {\sc S-Resolve} rule
solves $\CResolve{\r{x}}{\delta}$ constraints using the resolution
algorithm from \Figure{name-resolution}. If a resolution is found, it
is substituted for the variable $\delta$. If the scope graph is
incomplete, the algorithm might throws an exception, in which case the
constraint is left to to be solved later.

The {\sc S-Assoc} rule solves $\CAssoc{\d{x}}{\varsigma}$ constraints,
by looking up the scope $S$ associated with ground declaration $\d{x}$ in the
scope graph. By subtituting $S$ for $\varsigma$, the scope graph
becomes more complete, possible allowing more references to be
resolved.

Rule {\sc
  S-Equal} solves equality constraints $\CEqtype{T_1}{T_2}$. It uses first order unification $\unify{T_1}{T_2}$, as described in
\cite{0092409}. The resulting substitution is applied to the tuple.

Rule {\sc S-Subtype} solves constraints of the form
$\CSubtype{t_1}{t_2}$ by checking that $t_1 \leq_{\overline{\leqa}} t_2$ for the
ground types $t_1$ and $t_2$. The check might not succeed if $\leqa$
still contains variables, in which case it might be solved later.

Rule {\sc S-Lub} solves $\CLub{T}{t_1}{t_2}$ constraints. It does so
by calculating the least upper bound $t = \lub{t_1}{t_2}$ of the
ground types $t_1$ and $t_2$ and generating a new equality constraint
$\CEqtype{T}{t}$. The solver depends here on a language specific
least upper bound function $\sqcup$, which for LMR is presented in
\Figure{solver-functions-LMR} in the Appendix.

Constraints of the form $\CType{\d{x}}{T}$ are solved by rule {\sc
  S-TypeOf}. The first rule is used
the first time $\d{x}$ is encountered and just adds it to the typing
environment. For every next encounter, the other rule unifies the type
$T$ from the constraint with the type $\psi(\d{x})$ from the typing
environment. 

The trivial constraint $\CTrue$ is handled by {\sc S-True}.


\subsection{Correctness}

