\section{Related Work}\sectionlabel{related-work}

\paragraph{Binding-sensitive program representations.}

There has been a great deal of work on representing program syntax in
ways that take explicit note of binding structure, usually with the goal
of supporting program transformation or mechanized reasoning tools that
respect $\alpha$-equivalence by construction. Notable techniques include
de Bruijn indexing \cite{deBruijn72}, Higher-Order Abstract Syntax
(HOAS) \cite{DBLP:conf/pldi/PfenningE88}, locally nameless representations
\cite{Chargueraud12}, and nominal sets
\cite{GabbayP02}. (Aydemir, et al.
\cite{AydemirCPPW08} give a survey in the context of mechanized
reasoning.) However, most of this work has concentrated on simple
lexical binding structures, such as single-argument $\lambda$-terms.
Cheney \cite{Cheney05a} gives a catalog of more
interesting binding patterns and suggests how nominal logic can be used
to describe many of them. However, he leaves treatment of module imports
as future work.

\paragraph{Binding specification languages.}

The \emph{Ott} system \cite{SewellNOPRSS10} allows definition of syntax,
name binding and semantics. This tool generates language definitions for
theorem provers along with a notion of $\alpha$-equivalence and
functions such as capture-avoiding substitution that can be proven
correct in the chosen proof assistant modulo 
$\alpha$-equivalence. Avoiding capture is also the basis of hygienic
macros in Scheme. Dybvig \cite{DybvigHB92} gives an algorithmic
description of what hygiene means. Herman and Wand
\cite{HermanW08,Herman2010} introduce static binding specifications to
formalize a notion of $\alpha$-equivalence that does not depend on macro
expansion. Stansifer and Wand's Romeo system
\cite{StansiferW14} extends these specifications to somewhat
more elaborate binding forms, such as sequential \pcfmcode{let}.
\emph{Unbound} \cite{WeirichYS11} is another recent
domain specific language for describing bindings that supports
moderately complex binding forms. Again, none of these systems treat
modules or imports.

\paragraph{Language engineering.}

In language engineering approaches, name bindings are often realized using a random-access symbol table such that multiple analysis and transformation stages can reuse the results of a single name resolution pass \cite{AhoSU86}. Another approach is to represent the result of name resolution by means of \emph{reference attributes}, direct pointers from
the uses of a name to its definition \cite{HedinM03}. However these representations are usually built using an implementation of a language-specific resolution algorithm. 
Erdweg, et al. \cite{ErdwegSD14} describe a system for defining capture-free transformations,
assuming resolution algorithms are provided for the source and target languages. The approach represents the result of name resolution using ‘name graphs’ that map uses to definitions (references to declarations in our terminology) and are language independent.
This notion of ‘name graph’ inspired our notion of ‘scope graph’. The key difference is that the results of name resolution generated by the resolution calculus are \emph{paths} that extend a use-def pair with the \emph{language-independent evidence} for the resolution.

\paragraph{Semantics engineering.}

Semantics engineering approaches to name binding vary from first-order
representation with substitution \cite{KleinCDEFFMRTF12}, to explicit or
implicit environment propagation
\cite{Pierce2002,Mosses-JLAP-2004,ChurchillMT14}, to HOAS
\cite{Chlipala10}. Identifier bindings represented with environments are
passed along in derivation rules, rediscovering bindings for each
operation. This approach is inconvenient for more complex patterns such
as mutually recursive definitions.
