\chapter{Transformation with Stratego}
\chapterlabel{transformation}

The parsers generated from SDF3 syntax definitions produce abstract syntax
terms. Semantic manipulation of programs in Spoofax is done by manipulating
these terms. In this chapter we study the definition of transformations on
(abstract syntax) terms with the Stratego strategic rewriting language.

\begin{figure}[p]
\begin{minipage}[t]{0.47\hsize}
\lstinputlisting[language=paplj]{../languages/LanguageB/examples/expr/let-do.lb}
\end{minipage}
\hfill
\begin{minipage}[t]{0.47\hsize}
\lstinputlisting[language=paplj]{../languages/LanguageB/examples/expr/let-do.desugared.lb.txt}
\end{minipage}
\caption{Program before and after desugaring (concrete syntax).}
\bigskip
\figurelabel{desugaring-concrete}
\lstinputlisting[language=aterm]{../languages/LanguageB/examples/expr/let-do.aterm.txt}
\lstinputlisting[language=aterm]{../languages/LanguageB/examples/expr/let-do.desugared.aterm.txt}
\caption{Program before and after desugaring (abstract syntax).}
\figurelabel{desugaring-abstract}
\end{figure}

\section{Term Transformations}

A desugaring transformation simplifies the programs of a language to use only a
subset of the constructs of the language or only simplified applications of
constructs. 
For example, \Figure{desugaring-concrete} shows a program before and after
desugaring let bindings and sequential compositions. After desugaring, let
bindings contain only a single binding sequential composition `blocks' contain
at most two expresssions (and no `skips').
\Figure{desugaring-abstract} shows the abstract syntax term of the same
program before and after desugaring.

\Figure{Terms.sdf3} defines the syntax of the format of terms that we use here.
A term is a string literal, a number literal, a constructor application, or a
list of terms (between square brackets.)
The algebraic signature corresponding to a syntax definition describes the
subset of terms that are well-formed abstract syntax terms.

Thus, defining a transformation such as desugaring on programs, requires a
transformation on the underlying abstract syntax terms. 
The Stratego language supports the definition of such transformations by means
of term rewrite rules.

\begin{figure}
\lstinputlisting[language=SDF]{../languages/Stratego/syntax/Terms.sdf3}
\caption{Syntax of terms.}
\figurelabel{Terms.sdf3}
\end{figure}


\section{Term Rewrite Rules}

A term rewrite rule is a schematic description of a transformation on terms.
For example, the rule

\begin{lstlisting}[language=Stratego]
desugar-let :
  Let([b1, b2 | bs], e) -> Let([b1], Let([b2 | bs], e))
\end{lstlisting}

transforms a \texttt{Let} term with a list containing at least two bindings
(\texttt{b1} and \texttt{b2}) and some other bindings (\texttt{bs}), into a
\texttt{Let} term with the first binding \texttt{b1} and a nested \texttt{Let}
with the other bindings.
In general, a term rewrite rule has the form

\begin{lstlisting}[language=Stratego]
l : lhs -> rhs
\end{lstlisting}

where \texttt{l} is the name of the rule, and \texttt{lhs} and \texttt{rhs} are
\emph{term patterns}.
A rewrite rule applies to a term if the left-hand side pattern \emph{matches}
the term, and results in the instantiation of the right-hand side pattern,
replacing the pattern variables with the terms bound to them by the match.

\Figure{desugar-rules.str} gives more examples of desugaring rules on
expressions.


\begin{figure}[t]
\lstinputlisting[language=Stratego]{../languages/LanguageB/trans/desugar-rules.str}
\caption{Term rewrite rules for desugaring expressions.}
\figurelabel{desugar-rules.str}
\end{figure}


\paragraph{Term Patterns and Pattern Matching}

A term \texttt{pattern} is a term extended with variables and list match
patterns as formalized by the syntax definition in \Figure{Patterns.sdf3}.
Roughly, a term matches a pattern if it has the same
shape as the pattern. That is, a term matches a pattern if its outermost constructor is the
same as the outermost constructor of the pattern, and the sub-terms match the
corresponding sub-patterns, or the pattern is a variable.
\Figure{pattern-matching} gives a precise definition of pattern matching.

\begin{figure}[p]
\lstinputlisting[language=SDF]{../languages/Stratego/syntax/Patterns.sdf3}
\caption{Syntax of patterns.}
\figurelabel{Patterns.sdf3}
\bigbreak
\begin{boxedminipage}{\hsize}
A term matches a term pattern if one of the following cases aplies
\begin{itemize}
  \item The pattern is string literal and the term is the same string literal.
  \item The pattern is a number literal and the term is the same number literal.
  \item The pattern is a constructor application \oldtexttt{c(p$_1$,..,p$_n$)}, the
  term is a constructor application \oldtexttt{c(t$_1$,..,t$_n$)} of the same
  constructor \oldtexttt{c}, and the sub-patterns \oldtexttt{p$_1$,..,p$_n$} match the sub-terms
  \oldtexttt{t$_1$,..,t$_n$}.
  \item The pattern is a list pattern \oldtexttt{[p$_1$,..,p$_n$]}, the term is a list
  \oldtexttt{[t$_1$,..,t$_n$]}, and the patterns \oldtexttt{p$_1$,..,p$_n$} match the
  terms \oldtexttt{t$1$,..,t$_n$}.
  \item The pattern is a list pattern \oldtexttt{[p$_1$,..,p$_n$|p]}, the term is a list
  \oldtexttt{[t$_1$,..,t$_m$]}, $n \leq m$, the patterns \oldtexttt{p$_1$,..,p$_n$}
  match the terms \oldtexttt{t$_1$,..,t$_n$}, and the pattern \oldtexttt{p} matches
  \oldtexttt{[t$_{m+1}$,..,t$_m$]}.
  \item The pattern is a pattern variable, in which case the term is bound to
  the variable.
\end{itemize}
\end{boxedminipage}
\caption{Definition of term pattern matching.}
\figurelabel{pattern-matching}
\end{figure}


\section{Term Rewriting Strategies}

Term rewriting is the process of applying term rewrite rules to (the sub-terms
of) a term until a \emph{normal form} is reached. That is, until no more
sub-terms match the left-hand side of a rule. In traditional rewrite engines,
rules would be applied using a standard \emph{strategy} to find \emph{reducible
expressions} (also known as \emph{redices}).
However, in practice rewrite rules (for program transformation) may be
\emph{non-confluent}, i.e. produce multiple different results depending on the
application order, and/or may be \emph{non-terminating}. Circumventing such
problems in a traditional rewrite engine requires extending terms with
additional information in order to control execution.

In order to provide more control over the rewriting process, Stratego supports
\emph{programmable} rewriting strategies, which make it possible to
\emph{select} the rules to apply and to determine the search algorithm used to
find redices.
Indeed, such strategies do not necessarily lead to a (unique) normal form in the
traditional sense.

\begin{figure}[t]
\lstinputlisting[language=Stratego]{../languages/LanguageB/trans/traversals.str}
\caption{Definitions of traversal strategies (included in the standard
Stratego library).}
\figurelabel{traversals.str}
\end{figure}

A Stratego strategy is a partial function from terms to terms. A strategy is a
partial function since the application to a term may fail. For example, applying
a rewrite rule to a term fails if the term does not match the left-hand side of
the rule. Strategies are defined in terms of a small set of strategy
combinators:

\begin{description}
\item[\oldtexttt{id}] The identity strategy always succeeds and returns the term
to which it is applied.
\item[\oldtexttt{fail}] The failure strategy always fails.
\item[\oldtexttt{l}] The application of a rewrite rule by invoking its name
\oldtexttt{l}. If successful, returns the instantiation of the right-hand side
of the rule.
\item[\oldtexttt{s$_1$; s$_2$}] The sequential composition of two strategies.
\oldtexttt{s$_2$} is applied to the term returned by the
application of \oldtexttt{s$_1$}. Fails if either strategy fails.
\item[\oldtexttt{s$_1$ <+ s$_2$}] The ordered choice between two strategies.
If the application of \oldtexttt{s$_1$} is successful, its result is returned,
otherwise \oldtexttt{s$_2$} is applied to the original term.
\item[\oldtexttt{all(s)}] A one-level traversal operator that visit all direct
sub-terms of a term, applying \oldtexttt{s} to each, returning the application
of the original constructor to the transformed sub-terms.
\item[\oldtexttt{one(s)}] This one-level traversal operator visits the direct
sub-terms of a term from left to right, applying \oldtexttt{s} until it
succeeds, returning the original term with the first sub-term for which
\oldtexttt{s} succeeds replaced.
\end{description}

\Figure{traversals.str} shows the application of these combinators in the
definition of several strategies from the standard Stratego library.
\Figure{desugar.str} uses the \texttt{innermost} strategy to define several
desugaring transformations using the desugaring rules from
\Figure{desugar-rules.str}.

\begin{figure}[t]
\lstinputlisting[language=Stratego]{../languages/LanguageB/trans/desugar.str}
\caption{Strategies for desugaring expressions.}
\figurelabel{desugar.str}
\end{figure}


\section{Conditional and Parameterized Rules}

In \Figure{traversals.str} we saw that strategy definitions can be parameterized
with strategy arguments. The strategy \texttt{bottomup(s)} takes a strategy
parameter \texttt{s} that is instantiated with some transformation to apply to
each node of a term. Rules can be parameterized in the same way.
\Figure{list-strategies.str} gives examples of such parameterized rules. For
example, the \texttt{map(s)} rule applies a transformation \texttt{s} to all the
elements of a list, and \texttt{filter(s)} filters the elements of a list using
(the success/failure behaviour of) the transformation parameter \texttt{s}. 

application of a strategy


rule with side conditions

where

with

\begin{figure}[t]
\lstinputlisting[language=Stratego]{../languages/LanguageB/trans/list-strategies.str}
\caption{Parameterized rules.}
\figurelabel{list-strategies.str}
\end{figure}

\section{String Interpolation}

generating strings

\texttt{$[.. [] ..]}


\begin{figure}[t]
\lstinputlisting[language=Stratego]{../languages/LanguageB/trans/to-xml.str}
\caption{Using string interpolation to translate programs to textual XML
representation.}
\figurelabel{to-xml.str}
\end{figure}

\section{Spoofax Builders}

builders are actions that can be applied to program from the editor

definition of these actions consists of three ingredients

the definition of the transformation to apply

the defnition of the menu entry

the glue code that turns a regular AST transformation into a Spoofax builder
that can be called from a menu

interface wih editor


\begin{figure}[p]
\lstinputlisting[language=ESV]{../languages/LanguageB/editor/LangB-Menu-Transformation.esv}
\caption{Configuration of Transformation menu.}
\figurelabel{LangB-Menu-Transformation.esv}
\bigskip
\lstinputlisting[language=Stratego]{../languages/LanguageB/trans/builders/desugar.str}
\caption{Configuration of Transformation menu.}
\figurelabel{LangB-Menu-Transformation.esv}
\end{figure}





\section{Further Reading}

\cite{Klint93,BrandDHJJKKMOSVVV01}: ASF+SDF MetaEnvironment

term rewriting, innermost rewriting strategy

strategies in ELAN \cite{BorovanskyKKMV96,BorovanskyKKMR98}

\cite{VisserBT98}: first definition of Stratego

\cite{JongeVV01}: XT

\cite{Visser01}: Stratego RTA'01

\cite{Visser03}: Stratego/XT 0.9

\cite{BravenboerKVV08}: Stratego/XT 0.17

\cite{HemelKGV10}: code generation by model transformation


\cite{Visser02}: meta-programming with concrete object syntax

\paragraph{Online Documentation}

The
online \href{http://releases.strategoxt.org/strategoxt-manual/strategoxt-manual-0.17pre18721-8c3vml4h/manual/
}{StrategoXT manual} \cite{StrategoXTReferenceManual}

In particular, 
\href{http://releases.strategoxt.org/strategoxt-manual/strategoxt-manual-0.17pre18721-8c3vml4h/manual/chunk-chapter/stratego-language.html}{Part
III. The Stratego Language} provides an extended introduction to the language.


\href{http://releases.strategoxt.org}{releases.strategoxt.org}

