module trans/semantics/interpret

imports trans/semantics/values

signature
  arrows 
    Program --> V 
    Expr --> V  
    List(Expr) --> List(V)

rules

  Program(_, cs, e) --> v
  where C initClasses(cs) |- e --> v.
    
rules // boolean expressions
   
  True()  --> BoolV(false). 
  False() --> BoolV(false). 
  
  Not(BoolV(true)) --> BoolV(false).
  Not(BoolV(false)) --> BoolV(true).
      
  // And
  
//  And(BoolV(false), _) --> BoolV(false). 
//  And(BoolV(true), e)  --> e.
   
  // Or
  // If
  
rules // control-flow

  Do([]) --> U().
  
  Do([v]) --> v.
  
  Do([v | stats@[_|_]]) --> Do(stats).
  
rules // arithmetic expressions

  Num(i) --> NumV(str2int(i)).
  
  Min(NumV(i)) --> NumV(minusI(0, i)).
  
  // Add
  // Sub
  // Mul
  
  Neq(e1, e2) --> Not(Eq(e1, e2)).
  
  Eq(NumV(i), NumV(j)) --> BoolV(eqI(i, j)).
  
  Lt(NumV(i), NumV(j)) --> BoolV(gtI(j, i)).
   
rules // variables

  // Var(x)
  // Let([], e)
  // Let([Bind(t, x, v)  | binds], e)
  
  Var(x) --> NumV(1).

//  Var(x) --> readVar(x).
//  
//  Let([], v) --> v.
//  
//  Let([Bind(_, x, v) | binds], e) --> v'
//  where Env bindVar(x, v) |- Let(binds, e) --> v'.
  
rules // objects
 
  New(c) --> initObject(loadClass(c)).
      
  Get(o, ClassT(c), f) --> readField(o, c, f).    
    
  Set(o, ClassT(c), f, v) --> writeField(o, c, f, v).
  
  Null(_) --> NullV().
     
  Call(o, m, vs: List(V)) --> v'
  where lookupMethod(o, m) --> Method(_, _, params, e);
        This o, Env bindVars(params, vs) |- e --> v'. 

  This o |- This() --> o.  
  
  Cast(t1, o@ObjV(t2, _, _, _)) --> o.
  
rules // list of expressions

  []: List(Expr) --> [].
  
  [v | es] : List(Expr) --> [v | vs]
  where es --> vs.
  